
**************
IMPORTANT : PARAMETER FOR SORTING
**************

1) Worst and average case time complexity
2) Best case time complexity
3) Auxiliary space (extra or temp space used )
4) Boundary cases
5) Sorting in place ? (without any extra space)
6) Stable sort ? (two records with same key maintains initial order)



#Bubble sort
- adjacent elements swap(just like bubble going up one by one) until highest element reaches the end .
- in next iteration it goes till n-1...and same
- complexity n+(n-1)....0 = n^2
- imp. to reduce complexity take boolean and exit in iteration when no swap is there
- analysis and find out the PARAMETERS FOR SORTING values

#Selection sort
- calculate the min element from R.H.S of selected element and replace with starting in unsorted array
- complexity n^2

#Insertion sort
-calculate the position to L.H.S of selected element and insert the element at right position by shifting the elements to the right of the
 position by 1

#Merge Sort
-Two functions 1) divide 2) merge
- complexity nLog(n)


#Quick Sort
-

#Heap Sort
-Heapify and remove
-Min heap , max heap
-https://www.programiz.com/dsa/heap-sort
- for slightly better optimisation start the root with 1 instead of 0 so that
  we don't have to add +1 in left child and same for finding the parent we don't have to add
  -1 in it...so left child = i*2, right = i*2+1,parent = i/2 ;
